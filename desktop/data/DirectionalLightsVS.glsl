//estos atributos vienen del archivo .OBJattribute vec4 a_position;attribute vec4 a_color;attribute vec2 a_texCoord0;attribute vec4 a_normal;//estos uniforms son seteados por mi aplicacionuniform mat4 u_mvp;//estos varying son el OUTPUT de mi vertex shader//el OUTPUT del vertex shader es efectivamente el INPUT del //fragment shadervarying vec4 v_color;varying vec2 v_texCoords;//iluminacionvarying vec4 v2f_normalW;varying vec4 v2f_positionW;uniform vec3 EyePosW3;uniform vec3 LightPosW_3; // Light's position in world space.uniform vec3 MaterialDiffuse_3;//este es mi Vertex Shader void main(){    v_color = vec4(1, 1, 1, 1);    v_texCoords = a_texCoord0;        //esta linea transforma la posicion del vertice (en coordenadas locales)    //a coordenadas de mundo, luego a coordenadas de vista    //y por ultimo a coordenadas NDC (proyectadas)    gl_Position =  u_mvp * a_position;            //para poder dibujar distintos objetos (o distintas naves)    //es necesario introducir el valor (distinto) de mvp antes de     //dibujar cada nave            //parametros de iluminaci√≥n al fragment    v2f_normalW = u_mvp* a_normal;    v2f_positionW = u_mvp * a_position;             //            vec3 normal, lightDir;	vec4 diffuse;	float NdotL;	/* first transform the normal into eye space and normalize the result */	normal = normalize( u_mvp* a_normal);	/* now normalize the light's direction. Note that according to the	OpenGL specification, the light is stored in eye space. Also since	we're talking about a directional light, the position field is actually	direction */	lightDir = normalize(vec3(LightPosW_3));	/* compute the cos of the angle between the normal and lights direction.	The light is directional so the direction is constant for every vertex.	Since these two are normalized the cosine is the dot product. We also	need to clamp the result to the [0,1] range. */	NdotL = max(dot(normal, lightDir), 0.0);	/* Compute the diffuse term */	diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse;	gl_FrontColor =  NdotL * diffuse;	gl_Position = ftransform();}